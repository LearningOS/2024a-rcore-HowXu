# 简答作业

## How I finish

直接从ch3的断言上可以看到这个题的大概逻辑。  
首先是关于Status的项，题干已经说了是Running就直接返回就可以了。  
Sys_Calls的统计要在Trap的SysCall之前进行，否则SysInfo是统计不到的。除了桶计数当然也可以直接用结构体。  
最后是时间的计算，这里首先要确保能够拿到第一次运行时的时间，然后再在每次run_next的时候更新时间就可以了，大体上设置两个变量和一个判断就行。  
这里注意到统计包括计数是是不能够直接接触到TaskManager全局变量的，所以函数都要进行对外接口  

## 简答

1. (1)BadAdress是直接向`0x0`段写入0，`0x0`是一段被保护的不允许用户态程序访问的地址，因此一定会panic。
   (2)instructions是直接调用汇编进行return操作，从一个用户态到另一个用户态，这里不会panic因为会直接返回到shell。
   (3)register是从sstatus寄存器中读取值并打印。

2. (1)此处a0应该指向之前的栈指针;用于上下文切换调度，用于用户态和内核态的切换.
   (2)sstatus sepc sscratch:记录运行特权，异常处理的中断状态，内核态之前的用户栈指针。三者是运行态切换和异常处理的核心所在。
   (3)x2是栈指针 已经被保存在sscratch中;x4是线程指针，极少参与以上过程，无需保存
   (4)这一行之后sp会恢复到上一次运行的栈指针，sscratch仍然保存上一次运行的栈指针。
   (5)L61 状态切换 sret会返回到用户态继续执行。
   (6)sp保存内核栈指针 sscratch保存用户栈指针 确保trap结束后可以换回去。
   (7)L13
